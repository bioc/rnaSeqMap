##### all normalizations for NucleotideDistr objects# MO, AL 11.7.11######################################################standarizationNormalize <- function(nd) {	ndout <- nd	dd1 <- RleList2matrix(nd@data)	a <- dim(dd1)[1]   # num of rows	b <- dim(dd1)[2]   # num cols	dd <- matrix(,a,b)  		for (i in 1:b){		dd[,i]<-((dd1[,i]-mean(dd1[,i]))/sd(dd1[,i])+(abs(min(dd1[,i]))))	}	ndout@data <- .fillRleList(dd)	ndout}# squeezes the distrib into the range 0-1min_maxNormalize <- function(nd){    ndout <- nd	dd1 <- RleList2matrix(nd@data)	a <- dim(dd1)[1]   # num of rows	b <- dim(dd1)[2]   # num cols	dd <- matrix(,a,b)  	for (i in 1:b){		mian <- max(dd1[,i])-min(dd1[,i])		if (mian==0) mian <- 1			#constant coverage case, most likely 0, so we enter any constant and out is 0		 		dd[,i]<-(dd1[,i]-min(dd1[,i]))/mian}	ndout@data <- .fillRleList(dd)	ndout}# divides each profile by the sum of coverage in this profiledensityNormalize <- function(nd){	ndout <- nd	dd1 <- RleList2matrix(nd@data)	a <- dim(dd1)[1]   # num of rows	b <- dim(dd1)[2]   # num cols	dd <- matrix(,a,b) 		for (i in 1:b){		ss <- sum(dd1[,i])		if (ss!=0) dd[,i]<- dd1[,i]/ss			        if (ss==0) dd[,i]<- dd1[,i]     # for borderline cases when dd1[,i]==0, the output is 0 too 		}	ndout@data <- .fillRleList(dd)	ndout}# sums vector must have as many numbers as nd has samplesglobalCountsNormalize <- function(nd, sums){		ndout <- nd	dd1 <- RleList2matrix(nd@data)	a <- dim(dd1)[1]   # num of rows	b <- dim(dd1)[2]   # num cols	dd <- matrix(,a,b) 	mm <- max(sums)    	for (i in 1:b){			scalingFact <- mm/sums[i] 			dd[,i]<- dd1[,i]*scalingFact}		ndout@data <- .fillRleList(dd)	ndout}############# utilities .fillRleList <- function(m) # m is a matrix, subsequent columns are changed into Rle objects{  	out <- list()	cc <- dim(m)[2]	for (i in 1:cc)	{		out[[i]] <- Rle(m[,i])	}	out}